import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';

export interface ComplianceAlert {
  id: string;
  employerId: string;
  alertType: 'contract_expiry' | 'bpjs_overdue' | 'overtime_limit' | 'document_missing' | 'tax_deadline' | 'labor_law_violation';
  severity: 'critical' | 'warning' | 'info';
  title: string;
  message: string;
  relatedEntityId?: string;
  relatedEntityType?: string;
  dueDate?: string;
  resolvedAt?: string;
  resolvedBy?: string;
  autoGenerated: boolean;
  metadata?: Record<string, any>;
  createdAt: string;
}

export interface AuditLog {
  id: string;
  employerId: string;
  userId: string;
  userName: string;
  action: string;
  entityType: string;
  entityId: string;
  changes?: Record<string, any>;
  ipAddress?: string;
  userAgent?: string;
  createdAt: string;
}

export const complianceKeys = {
  all: ['compliance'] as const,
  alerts: () => [...complianceKeys.all, 'alerts'] as const,
  alertsList: (employerId: string, filters?: any) => [...complianceKeys.alerts(), employerId, filters] as const,
  auditLogs: () => [...complianceKeys.all, 'audit-logs'] as const,
  auditLogsList: (employerId: string, filters?: any) => [...complianceKeys.auditLogs(), employerId, filters] as const,
};

/**
 * Fetch compliance alerts
 */
export function useComplianceAlerts(
  employerId: string | null,
  filters?: { severity?: string; status?: 'active' | 'resolved' }
) {
  return useQuery({
    queryKey: complianceKeys.alertsList(employerId!, filters),
    queryFn: async () => {
      const params = new URLSearchParams();
      if (filters?.severity) params.append('severity', filters.severity);
      if (filters?.status) params.append('status', filters.status);

      const response = await fetch(`/api/v1/compliance/alerts?${params.toString()}`);
      if (!response.ok) throw new Error('Failed to fetch compliance alerts');
      return response.json() as Promise<{ alerts: ComplianceAlert[]; total: number }>;
    },
    enabled: !!employerId,
    refetchInterval: 60000, // Refetch every minute for critical alerts
  });
}

/**
 * Resolve compliance alert
 */
export function useResolveAlert() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ alertId, notes }: { alertId: string; notes?: string }) => {
      const response = await fetch(`/api/v1/compliance/alerts/${alertId}/resolve`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ notes }),
      });
      if (!response.ok) throw new Error('Failed to resolve alert');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: complianceKeys.alerts() });
      toast.success('Alert resolved successfully');
    },
    onError: (error: Error) => {
      toast.error('Failed to resolve alert', {
        description: error.message,
      });
    },
  });
}

/**
 * Fetch audit logs
 */
export function useAuditLogs(
  employerId: string | null,
  filters?: { userId?: string; action?: string; entityType?: string; startDate?: string; endDate?: string }
) {
  return useQuery({
    queryKey: complianceKeys.auditLogsList(employerId!, filters),
    queryFn: async () => {
      const params = new URLSearchParams();
      if (filters?.userId) params.append('userId', filters.userId);
      if (filters?.action) params.append('action', filters.action);
      if (filters?.entityType) params.append('entityType', filters.entityType);
      if (filters?.startDate) params.append('startDate', filters.startDate);
      if (filters?.endDate) params.append('endDate', filters.endDate);

      const response = await fetch(`/api/v1/compliance/audit-logs?${params.toString()}`);
      if (!response.ok) throw new Error('Failed to fetch audit logs');
      return response.json() as Promise<{ logs: AuditLog[]; total: number }>;
    },
    enabled: !!employerId,
  });
}
